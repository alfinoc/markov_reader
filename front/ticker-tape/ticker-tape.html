<link rel="import" href="ticker-tape-line.html">

<polymer-element name="ticker-tape">
   <template>
      <link rel="stylesheet" type="text/css" href="ticker-tape.css">
      <div id="text">
         <div id="placeholder"></div>
      </div>
   </template>
   <script>

Polymer('ticker-tape', {
   created: function() {
      this.bufferPixels = 100;
      this.lastLineHeight = 0;
   },

   domReady: function() {
      this.sources = this.querySelectorAll('text-source').array();
      //this.$.text.style.top = this.clientHeight + 'px';
      this.refreshBuffer();
      //setInterval(this.scrollUpOneLine.bind(this), 5000);
   },

   pause: function() {
      this.paused = true;
   },

   play: function() {
      this.paused = false;
   },

   refreshBuffer: function() {
      this.pause();
      this.garbageCollectLines();
      for (var i = 0; i < 10; i++)
         this.loadNewLine();
      this.play();
   },

   loadNewLine: function() {
      var newLine = this.getNextLine();
      this.$.text.appendChild(newLine);
      this.lastLineHeight = newLine.clientHeight;
   },

   scrollUpOneLine: function() {
      if (!this.paused) {
         this.async(function() {
            var textStyle = this.$.text.style;
            textStyle.top = parseInt(textStyle.top) - this.lastLineHeight + 'px';
         });
      }
   },

   garbageCollectLines: function() {
      this.$.text.classList.add('suspendtransition');
      var lines = this.$.text.children;
      var textStyle = this.$.text.style;
      while (parseInt(textStyle.top) < -this.bufferPixels) {
         if (lines.length > 1) {
            // The placeholder is lines[0], so remove the next.
            var height = lines[1].clientHeight;
            lines[1].remove();
            textStyle.top = parseInt(textStyle.top) + height + 'px';
         } else {
            break;
         }
      }
      this.$.text.classList.remove('suspendtransition');
   },

   getNextLine: function() {
      // Fill the placeholder with words until it overflows to a second line.
      var placeholder = this.$.placeholder;
      var appendNextSpan = function() {
         var span = document.createElement('span');
         span.innerHTML = this.sources[0].peek();
         placeholder.appendChild(span);
         return span;
      }.bind(this);
      // Prime with one token to get computed line height.
      appendNextSpan();
      var initialHeight = placeholder.clientHeight;
      while (placeholder.clientHeight == initialHeight) {
         this.sources[0].next();
         placeholder.innerHTML += ' ';
         appendNextSpan();
      }
      var newLine = document.createElement('div');
      newLine.innerHTML = placeholder.innerHTML;
      placeholder.innerHTML = '';
      return newLine;
      // TODO(bug): This doesn't handle hiphen word breaks well.
   },

   // adds a single line at the bottom
   spawnLine: function() {
      // TODO: source.isEmpty() check for when the source has no more words left (show loader).      
   },

   viewHeight: function() {
      return Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
   }
});

   </script>
</polymer-element>