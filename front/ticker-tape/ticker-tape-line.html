<link rel="import" href="../bower_components/paper-shadow/paper-shadow.html">
<link rel="import" href="../bower_components/paper-focusable/paper-focusable.html">

<polymer-element name="ticker-tape-line" attributes="height line">
   <template>
      <style>
         word-info:last-child {
            display: inline-flex;
            height: 0px;
            overflow: hidden;
         }
      </style>
      <template repeat="{{ word, i in line | toWordArray }}">
         <word-info isToggle word="{{ word }}"></word-info>
      </template>
   </template>
   <script>
      Polymer('ticker-tape-line', {
         publish: {
            line: ''
         },

         toWordArray: function(str) {
            return str.trim().split(" ");
         }
      });
   </script>
</polymer-element>

<polymer-element name="word-info" attributes="word" extends="paper-focusable">
   <template>
      <style>
         :host {
            position: relative;
            display: inline-block;
            outline: none;
         }

         td {
            text-align: center;
         }

         td:not([middle]) {
            font-size: smaller;
         }

         td[middle] {
            cursor: pointer;
         }

         /* Hack to create padding on the whole table. nth-child(2) is because
            :first-child is actually the template :( */
         td:nth-child(2) {
            padding-left: 5px;
            text-align: left;
         }

         td:last-child {
            padding-right: 5px;
            text-align: right;
         }

         /* TODO: Line height makes it so these are goofy. If line-height hacks
            can be resolved, this might be able to come back.
         tr:nth-child(2) td { padding-top: 5px; }
         tr:last-child td { padding-bottom: 5px; }
         */

         span:hover + #infobox, :host([active]) #infobox {
            opacity: 1;
           
         }

         :host([active]) #infobox {
            pointer-events: auto;
         }

         span {
            cursor: pointer;
         }

         #infobox {
            border-radius: 3px;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none;
            opacity: 0;
            z-index: 1;
            position: absolute;
            top: 0px;
            left: 0px;
            background-color: white;
            cursor: default;
         }

         table {
            border-collapse: collapse;
         }
      </style>
      <span>{{ word }}</span>
      <div id="infobox" class="light">
         <table>
            <template repeat="{{ row, i in completeTable }}">
               <tr>
                  <template repeat="{{ cell, j in row }}">
                     <td middle?="{{ isCenterCell(i, j, row.length) }}">{{ cell }}</td>
                  </template>
               </tr>
            </template>
         </table>
         <paper-shadow z="1"></paper-shadow>
      </div>
   </template>
   <script>
      Polymer('word-info', {
         publish: {
            word: '',
            snippet1: ['this', 'is', 'a', 'path', 'lolfive'],
            snippet2: ['f', 'ghelllllla', 'h', 'i', 'j']
         },

         computed: {
            completeTable: "union(toTable(snippet1), invertRows(toTable(snippet2)))"
         },

         domReady: function() {
            this.positionTable(this.$.infobox);
         },

         // Ensure all other word-info's are unselected.
         activeChanged: function() {
            if (this.active) {
               var infos = document.querySelectorAll('* /deep/ word-info[active]').array();
               infos.forEach(function(info) {
                  if (this != info)
                     info.active = false;
               }.bind(this));
            }
         },

         // Returns a 2D array with both dimensions set to snippet.length. In the entries
         // where i == j, holds snippet[i]. Otherwise, snippet[i][j] = '';
         toTable: function(snippet) {
            if (!snippet)
               return [];
            var table = [];
            for (var i = 0; i < snippet.length; i++) {
               var row = [];
               for (var j = 0; j < snippet.length; j++)
                  row.push('');
               row[i] = snippet[i];
               table.push(row);
            }
            table[Math.floor(i / 2)][Math.floor(j / 2)] = this.word;
            return table;
         },

         // Returns a new 2D array with each entry containing the non-empty entry from
         // table1 or table2. If both have non-empty entries, table1's is used. If
         // neither do, '' is used. Assumes table1 and table2 have matching dimensions.
         union: function(table1, table2) {
            var res = [];
            for (var i = 0; i < table1.length; i++) {
               var row = [];
               for (var j = 0; j < table1[i].length; j++)
                  row.push(table1[i][j] || table2[i][j] || '');
               res.push(row);
            }
            return res;
         },

         // Returns true iff i and j both equal length / 2 (int div).
         isCenterCell: function(i, j, length) {
            return i == j && i == Math.floor(length / 2);
         },

         // Returns a new 2D array with the entries of table except with the rows in
         // reverse order.
         invertRows: function(table) {
            var res = [];
            for (var i = table.length - 1; i >= 0; i--)
               res.push(table[i]);
            return res;
         },

         // Sets the top/left positions so that the middle <td> in table aligns with
         // the <td> marked with attribute 'middle'.
         positionTable: function(table) {
            var middle = table.querySelector('td[middle]');
            if (!middle) return;
            // TODO: figure out why this needs -1.
            table.style.top = -middle.offsetTop - 1 + 'px';
            table.style.left = -middle.offsetLeft - 1 + 'px';
         }
      });
   </script>
</polymer-element>
