<polymer-element name="ticker-tape-line" attributes="height line">
   <template>
      <style>
         word-info:last-child {
            display: inline-flex;
            height: 0px;
            overflow: hidden;
         }
      </style>
      <template repeat="{{ word, i in line | toWordArray }}">
         <word-info word="{{ word }}"></word-info>
      </template>
   </template>
   <script>
      Polymer('ticker-tape-line', {
         publish: {
            line: ''
         },

         toWordArray: function(str) {
            return str.trim().split(" ");
         }
      });
   </script>
</polymer-element>

<polymer-element name="word-info" attributes="word">

   <template>
      <style>
         :host {
            position: relative;
            display: inline-block;
         }

         .infobox {
            
         }

         td {
            text-align: center;
         }

         /* Hack to create padding on the whole table. nth-child(2) is because
            :first-child is actually the template :( */
         td:nth-child(2) { padding-left: 5px; }
         td:last-child { padding-right: 5px; }

         /* TODO: Line height makes it so these are goofy. If line-height hacks
            can be resolved, this might be able to come back.
         tr:nth-child(2) td { padding-top: 5px; }
         tr:last-child td { padding-bottom: 5px; }
         */

         span:hover + table {
            opacity: 1;
         }

         span {
            cursor: pointer;
         }

         table {
            border-radius: 3px;
            transition: opacity 0.2s ease-in-out;
            pointer-events: none;
            opacity: 0;
            position: absolute;
            top: 0px;
            left: 0px;
            border-collapse: collapse;
            z-index: 1;
         }
      </style>
      <span>{{ word }}</span>
      <table id="snippet1">
         <template repeat="{{ row, i in completeTable }}">
            <tr>
               <template repeat="{{ cell, j in row }}">
                  <td middle?="{{ isCenterCell(i, j, row.length) }}">{{ cell }}</td>
               </template>
            </tr>
         </template>
      </table>
   </template>
   <script>
      Polymer('word-info', {
         publish: {
            word: '',
            snippet1: ['this', 'is', 'a', 'path', 'lolfive'],
            snippet2: ['f', 'g', 'h', 'i', 'j']
         },

         computed: {
            completeTable: "union(toTable(snippet1), invertRows(toTable(snippet2)))"
         },

         domReady: function() {
            this.positionTable(this.$.snippet1);
         },

         // Returns a 2D array with both dimensions set to snippet.length. In the entries
         // where i == j, holds snippet[i]. Otherwise, snippet[i][j] = '';
         toTable: function(snippet) {
            if (!snippet)
               return [];
            var table = [];
            for (var i = 0; i < snippet.length; i++) {
               var row = [];
               for (var j = 0; j < snippet.length; j++)
                  row.push('');
               row[i] = snippet[i];
               table.push(row);
            }
            table[Math.floor(i / 2)][Math.floor(j / 2)] = this.word;
            return table;
         },

         // Returns a new 2D array with each entry containing the non-empty entry from
         // table1 or table2. If both have non-empty entries, table1's is used. If
         // neither do, '' is used. Assumes table1 and table2 have matching dimensions.
         union: function(table1, table2) {
            var res = [];
            for (var i = 0; i < table1.length; i++) {
               var row = [];
               for (var j = 0; j < table1[i].length; j++)
                  row.push(table1[i][j] || table2[i][j] || '');
               res.push(row);
            }
            return res;
         },

         // Returns true iff i and j both equal length / 2 (int div).
         isCenterCell: function(i, j, length) {
            return i == j && i == Math.floor(length / 2);
         },

         // Returns a new 2D array with the entries of table except with the rows in
         // reverse order.
         invertRows: function(table) {
            var res = [];
            for (var i = table.length - 1; i >= 0; i--)
               res.push(table[i]);
            return res;
         },

         // Sets the top/left positions so that the middle <td> in table aligns with
         // the <td> marked with attribute 'middle'.
         positionTable: function(table) {
            var middle = table.querySelector('td[middle]');
            if (!middle) return;
            // TODO: figure out why this needs -1.
            table.style.top = -middle.offsetTop - 1 + 'px';
            table.style.left = -middle.offsetLeft - 1 + 'px';
         }
      });
   </script>
</polymer-element>
